var documenterSearchIndex = {"docs":
[{"location":"reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = SystemLevelControl","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [SystemLevelControl]","category":"page"},{"location":"reference/#SystemLevelControl.AbstractFeedbackStructure","page":"API Reference","title":"SystemLevelControl.AbstractFeedbackStructure","text":"AbstractFeedbackStructure\n\nAn abstract type for specifying feedback structures.  Its main usage is to specialize type annotations of AbstractGeneralizedPlant's.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SystemLevelControl.AbstractGeneralizedPlant","page":"API Reference","title":"SystemLevelControl.AbstractGeneralizedPlant","text":"AbstractGeneralizedPlant{T<:Number,Ts<:AbstractFeedbackStructure}\n\nAn abstract type for subtyping generalized plant models.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SystemLevelControl.DualGeneralizedPlant","page":"API Reference","title":"SystemLevelControl.DualGeneralizedPlant","text":"DualGeneralizedPlant{T,Ts} <: AbstractGeneralizedPlant{T<:Number,Ts<:AbstractFeedbackStructure}\n\nA type representing an adjoint (or dual) state-space\n\nP^* = leftbeginarrayc  c c\n        A^*  C_1^*  C_2^* \n        hline\n        B_1^*  D_11^*  D_21^* \n        B_2^*  D_12^*  D_22^* \n      endarrayright\n\nnote: Note\nAvoid directly constructing objects of this type. Instead, create a P::GeneralizedPlant and use adjoint(P) function or P'.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SystemLevelControl.GeneralizedPlant","page":"API Reference","title":"SystemLevelControl.GeneralizedPlant","text":"GeneralizedPlant{T,Ts} <: AbstractGeneralizedPlant{T<:Number,Ts<:AbstractFeedbackStructure}\n\nA type representing a generalized state-space model\n\nP = leftbeginarrayc  c c\n        A  B_1  B_2 \n        hline\n        C_1  D_11  D_12 \n        C_2  D_21  D_22 \n      endarrayright\n\nSee the function Plant for a user-friendly constructor of generalized plants. For detailed instructions check the documentation on Plants and controllers.\n\nFields\n\nA::SparseMatrixCSC{T,Int}\nB₁::SparseMatrixCSC{T,Int}\nB₂::SparseMatrixCSC{T,Int}\nC₁::SparseMatrixCSC{T,Int}\nD₁₁::SparseMatrixCSC{T,Int}\nD₁₂::SparseMatrixCSC{T,Int}\nC₂::SparseMatrixCSC{T,Int}\nD₂₁::SparseMatrixCSC{T,Int}\nD₂₂::SparseMatrixCSC{T,Int}\n\n\n\n\n\n","category":"type"},{"location":"reference/#SystemLevelControl.GeneralizedSubPlant","page":"API Reference","title":"SystemLevelControl.GeneralizedSubPlant","text":"GeneralizedSubPlant{T,Ts} <: AbstractGeneralizedPlant{T<:Number,Ts<:AbstractFeedbackStructure}\n\nA type representing a partition of a state-space\n\ntildeP = leftbeginarrayc  c c\n        A_I_1J_1  B_1_I_1J_2  B_2_I_1J_3 \n        hline\n        C_1_I_2J_1  D_11_I_2J_2  D_12_I_2J_3 \n        C_2_I_3J_1  D_21_I_3J_2  D_22_I_3J_3 \n      endarrayright\n\nwhere I = (I_1I_2I_3) and J=(J_1J_2J_3) are the desired partition index sets.\n\nnote: Note\nAvoid directly constructing objects of this type. Instead, create a P::GeneralizedPlant and use view(P, I, J) with tuples I = (I₁,I₂,I₃) and J = (J₁,J₂,J₃) describing the desired paritioning. To materialize the subsystem into a new GeneralizedPlant, use copy.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SystemLevelControl.OutputFeedback","page":"API Reference","title":"SystemLevelControl.OutputFeedback","text":"OutputFeedback\n\nA wrapper type to specify output-feedback structures.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SystemLevelControl.StateFeedback","page":"API Reference","title":"SystemLevelControl.StateFeedback","text":"StateFeedback\n\nA wrapper type to specify state-feedback structures.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SystemLevelControl.Plant-Tuple","page":"API Reference","title":"SystemLevelControl.Plant","text":"P = Plant(A, B₁, B₂[, C₁, D₁₁, D₁₁, C₂, D₂₁, D₂₂])\n\nCreates a generalized plant model P::GeneralizedPlant{T,Ts} with matrices of type T<:Number and feedback structure Ts<:AbstractFeedback. \n\nIf the matrices C₂, D₂₁, and D₂₂ are unspecified, the function automatically sets C₂ = I   and returns a state-feedback plant (Ts<:StateFeedback). If the matrices C₂, D₁₁, and D₁₂  are unspecified, the function assumes the standard LQR-type reference signal z^Tz = x^Tx + u^Tu  with C₁ = [I; 0] and D₁₂ = [0; I].\n\nIn case D₁₁ = 0 and/or D₂₂ = 0, a matrix of appropriate dimensions is created. Similarly,  if C₂ = I then the output matrix of appropriate dimension is created.\n\nExamples\n\njulia> A = randn(100,100);  B₁ = randn(100,100);  B₂ = randn(100,50);\n\njulia> C₁ = randn(150,100);  D₁₂ = randn(150,50);\n\njulia> D₂₁ = randn(100,100);\n\njulia> P = Plant(A, B₁, B₂, C₁, 0, D₁₂, I, D₂₁, 0)\n350×250 GeneralizedPlant{Float64, OutputFeedback} w/ 100 states, 100 outputs, 50 controls.\n\njulia> P = Plant(A, B₁, B₂)\n350×250 GeneralizedPlant{Float64, StateFeedback} w/ 100 states, 100 outputs, 50 controls.\n\n\n\nP = Plant(Σ, DIMS)\n\nCreates a generalized plant model P::GeneralizedPlant{T,Ts} based on a single matrix representation Σ::AbstractMatrix to be partitioned according to dimensions DIMS = [Nx, Nz, Ny, Nw, Nu].\n\nIf length(DIMS) = 4, then a state-feedback plant is constructed by slicing Σ with DIMS = [Nx, Nz, Nw, Nu].\n\nExamples\n\njulia> A = randn(100,100);  B₁ = randn(100,100);  B₂ = randn(100,50);\n\njulia> C₁ = randn(150,100);  D₁₂ = randn(150,50);\n\njulia> D₂₁ = randn(100,100);\n\njulia> P = Plant([A B₁ B₂; C₁ zeros(150,100) D₁₂; I D₂₁ zeros(100,50)], [100, 150, 100, 100, 50])\n350×250 GeneralizedPlant{Float64, OutputFeedback} w/ 100 states, 100 outputs, 50 controls.\n\njulia> P = Plant([A B₁ B₂; C₁ zeros(150,100) D₁₂], [100, 150, 100, 50])\n350×250 GeneralizedPlant{Float64, StateFeedback} w/ 100 states, 100 outputs, 50 controls.\n\n\n\n\n\n","category":"method"},{"location":"manual/","page":"Manual","title":"Manual","text":"CurrentModule = SystemLevelControl","category":"page"},{"location":"manual/#ToDo","page":"Manual","title":"ToDo","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"CurrentModule = SystemLevelControl","category":"page"},{"location":"examples/#ToDo","page":"Examples","title":"ToDo","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SystemLevelControl","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\"><img alt=\"Logo\" src=\"assets/logo_SLS_bg.png\"></p>\n<h4 align=\"center\">Welcome to the documentation for SystemLevelControl.jl!</h4>","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SystemLevelControl.jl is a Julia toolbox for synthesizing controllers using the System Level Synthesis (SLS) methodology. The package provides a straightforward, @Distributed-enabled, interface for optimal and robust control of large-scale cyberphysical systems. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are still not on the official registry. To install SystemLevelControl.jl, run ","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(url=\"https://github.com/aaltoKEPO/SystemLevelControl.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation is organized in three sections:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Manual details the main concepts and methods implemented in the package. \nThe Examples section provides some tutorials on using the package for solving relevant benchmark problems.\nThe Reference section contains the documentation of all important types and functions from the library.","category":"page"},{"location":"#Notes","page":"Home","title":"Notes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis package is currently under active development. A stable version is to be released soon.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Although general-purpose, the SLS methodology was designed for large-scale cyberphysical systems with sparse communication and actuation networks. This is reflected on our design choices for the package: SystemLevelControl.jl focus on linear discrete-time systems represented through SparseArrays data-types. The linear fractional transformation (LFT) framework is used as the theoretical backbone of all methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We hope to improve SystemLevelControl.jl until it can serve as a general-purpose control framework (while still bringing all the power of SLS). In the meanwhile, we can recommend other excellent Julia packages for doing analysis or solving more general control problems:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ControlSystems.jl and its associated Ecosystem provide a wide collection of tools for analysis and design of control systems. It provides a similar interface as that of the popular Control Systems Toolbox in MATLAB®.\nJuMP.jl is perhaps the most popular modelling framework for mathematical optimization in Julia. A wide class of optimal control problems (including LMIs/SDPs) can be solved with this package. SystemLevelControl.jl actually use JuMP to solve SLS problems for the general cases.\nTrajectoryOptimization.jl is a popular framework for solving trajectory optimization problems in Julia, specially for applications in robotics. A distinct feature is the possibility to easily model nonlinear control problems.\nJuliaSimControl.jl is the package within the JuliaSim Ecosystem that allows for the modelling, analysis and deployment of control systems in a centralized package.","category":"page"}]
}
